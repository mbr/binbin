#!/usr/bin/python3
#
# anycite: Create biblatex sources from URLs and other data
#
# Copyright (c) 2016 Marc Brinkmann

# Permission is hereby granted, free of charge, to any person obtaining a
# copy of this software and associated documentation files (the "Software"),
# to deal in the Software without restriction, including without limitation
# the rights to use, copy, modify, merge, publish, distribute, sublicense,
# and/or sell copies of the Software, and to permit persons to whom the
# Software is furnished to do so, subject to the following conditions:

# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.

# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
# FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
# DEALINGS IN THE SOFTWARE.

from datetime import datetime
import re
import sys

import click
import requests


def get(url, *args, **kwargs):
    click.echo(url, err=True)
    resp = requests.get(url, *args, **kwargs)
    resp.raise_for_status()
    return resp


class CannotHandle(Exception):
    pass


class Handler(object):
    @classmethod
    def can_handle(cls, arg):
        raise NotImplementedError

    @classmethod
    def handle(cls, arg):
        raise NotImplementedError


class ISBNHandler(Handler):
    # uses Manas Tungare's ISBN-to-BibTeX converter
    # http://manas.tungare.name/software/isbn-to-bibtex/
    #
    # should probably create our own implementation here at some point, using
    # isbn_tools

    LOOKUP_URL = 'http://php.chimbori.com/_php/isbn/isbn-bibtex'

    @classmethod
    def can_handle(cls, arg):
        arg = arg.replace('-', '').replace(' ', '')
        arg.rstrip('X')

        return (len(arg) == 10 or len(arg) == 13) and arg.isnumeric()

    @classmethod
    def handle(cls, arg):
        arg = arg.replace('-', '').replace(' ', '')
        arg.rstrip('X')

        resp = requests.post(cls.LOOKUP_URL, data={'isbn': arg})
        resp.raise_for_status()

        # we need to remove the URL, since it is just an amazon affiliate link
        # FIXME: this results in a "trailing" comma if URL is the last field
        #        of the result
        return '\n'.join(line
                         for line in resp.text.splitlines()
                         if not line.lstrip().startswith('URL')) + '\n'


class GitHubHandler(Handler):
    REPO_RE = re.compile(
        r'https://github.com/([^/]+)/([^/]+)(?:/commit/([^/]+))?')
    API_BASE = 'https://api.github.com'
    SAFE_RE = re.compile('[^a-zA-Z0-9]')

    @classmethod
    def can_handle(cls, arg):
        return arg.startswith('https://github.com')

    @classmethod
    def handle(cls, arg):
        m = cls.REPO_RE.match(arg)

        if not m:
            raise CannotHandle('failed to parse GitHub URL: {}'.format(arg))

        user, repo, commit_id = m.groups()

        # fetch repo first
        resp = get(cls.API_BASE + '/repos/{}/{}'.format(user, repo))
        repo = resp.json()

        # then owner
        resp = get(cls.API_BASE + '/users/{}'.format(repo['owner']['login']))
        owner = resp.json()

        # then commit
        if not commit_id:
            commit_id = 'master'

        resp = get(cls.API_BASE + '/repos/{}/{}/git/commits/{}'.format(
            user, repo['name'], commit_id))
        commit = resp.json()

        from pprint import pprint
        pprint(repo)
        pprint(owner)
        pprint(commit)

        DT_FMT = "%Y-%m-%dT%H:%M:%SZ"

        created_date = datetime.strptime(repo['created_at'], DT_FMT)
        commit_date = datetime.strptime(commit['author']['date'], DT_FMT)

        # format based on http://academia.stackexchange.com/questions/14010/
        #                        how-do-you-cite-a-github-repository
        return format_bibtex(
            entry_type='online',
            bibtex_key='{}{:02d}'.format(
                cls.SAFE_RE.sub('', repo['name']), created_date.year % 100),
            Author=owner['name'],
            Url=repo['html_url'],
            Title=repo['description'],
            Publisher='GitHub',
            Journal='GitHub repository',
            Commit=commit['sha'],
            Date='{:04d}-{:02d}-{:02d}'.format(
                commit_date.year, commit_date.month, commit_date.day))


def format_bibtex(**kwargs):
    # FIXME: should be moved to latex package
    entry_type = kwargs.pop('entry_type')
    entry_type = entry_type[0].upper() + entry_type[1:].lower()

    key = kwargs.pop('bibtex_key')

    buf = '@{}{{{},\n'.format(entry_type, key)
    lines = []
    for k, v in sorted(kwargs.items()):
        # FIXME: do proper escaping
        assert '{' not in k
        assert '}' not in k
        assert '{' not in v
        assert '}' not in v
        lines.append('  {} = {{{}}}'.format(k, v))
    buf += ',\n'.join(lines)
    buf += '\n}\n'
    return buf


HANDLERS = [ISBNHandler, GitHubHandler]


@click.command()
@click.argument('location')
def anycite(location):
    for handler in HANDLERS:
        if handler.can_handle(location):
            try:
                result = handler.handle(location)
            except CannotHandle as e:
                click.echo('warning: {}'.format(e, err=1))
                continue
            break
    else:
        click.echo('No handler for location: {}'.format(location, err=1))
        sys.exit(1)

    click.echo(result)


if __name__ == '__main__':
    anycite()
