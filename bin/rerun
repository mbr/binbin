#!/usr/bin/env python3

import click
import subprocess
import sys
import threading
import time

QUIET = False


def limited_pipe(input, output, max):
    def _():
        count = 0

        while count < max:
            line = input.readline()
            if not line:
                # exit function once EOF has been reached
                return

            output.write(line)
            count += 1

        # additional lines come here
        erase = 0
        while True:
            line = input.readline()
            if not line:
                if erase != 0:
                    output.write(b'\n')
                return
            count += 1

            status = '{} additional lines.'.format(count)
            output.write(b'\b' * erase)
            output.write(status.encode('utf8'))
            output.flush()
            erase = len(status)

    return _


def banner(text):
    w, h = click.get_terminal_size()

    lines = []
    hr = ' ' * w

    lines.append(hr)

    l = len(text)
    if 6 < (w - 2) < l:
        l = w - 6
        text = text[:l] + '...'
        l += 3

    padding = max(0, (w - 2) - l)
    pad_left = padding // 2
    pad_right = padding // 2 + padding % 2

    lines.append(' ' + ' ' * pad_left + text + ' ' * pad_right + ' ')

    lines.append(hr)

    return '\n'.join(lines)


def exit_err(msg, exitcode=1):
    click.secho(msg, file=sys.stderr, fg='red')
    sys.exit(exitcode)


def info(msg):
    if not QUIET:
        click.echo(click.style('#', fg='cyan', bold=True) + ' ' + msg)


@click.command()
@click.argument('cmd', nargs=-1)
@click.option(
    '-d',
    '--delay',
    type=float,
    default=None,
    help='Delay (in seconds) before running the command')
@click.option(
    '-f',
    '--file',
    'files',
    multiple=True,
    default=['.'],
    help='file or dir to watch (default: .)')
@click.option(
    '-n',
    '--head',
    type=int,
    help='Show only first n lines of combined stdout and stderr')
@click.option(
    '-q',
    '--quiet',
    is_flag=True,
    default=False,
    help='Suppress all output not generated by the command itself')
@click.option(
    '-c',
    '--clear',
    is_flag=True,
    default=False,
    help='Clear screen before executing command')
@click.option(
    '-C',
    '--clear-and-banner',
    is_flag=True,
    default=False,
    help='Clear screen and output banner before executing command')
@click.option(
    '-R',
    '--rerun-on-success',
    type=float,
    default=None,
    help='Even if successful, rerun if execution took longer than '
    'this many seconds')
def cli(delay, files, head, cmd, quiet, clear, clear_and_banner, rerun_on_success):
    global QUIET
    QUIET = quiet

    if not cmd:
        exit_err('missing command')
        sys.exit(1)

    inotify_args = [
        'inotifywait',
        '--recursive',
        '--quiet',
        '--event',
        'modify,create,delete,move',
    ]

    inotify_args.extend(files)
    run_count = 0
    cmd_name = ' '.join(cmd)

    while True:
        run_count += 1
        if clear or clear_and_banner:
            click.clear()

            if clear_and_banner:
                banner_text = '{:6d} : {}'.format(run_count, cmd_name)
                click.secho(
                    banner(banner_text), bg='blue', fg='white', bold=True)
            sys.stdout.flush()

        # run command
        info('running ' + click.style('{}'.format(cmd_name), fg='yellow'))

        start = time.time()

        stdout = None
        stderr = None

        if head is not None:
            stdout = subprocess.PIPE
            stderr = subprocess.STDOUT

        p = subprocess.Popen(cmd, stdout=stdout, stderr=stderr)

        # We need to launch a thread that consumes stdout:
        if head:
            outputter = threading.Thread(target=limited_pipe(p.stdout, sys.stdout.buffer, head))
            outputter.start()

        p.wait()

        if head:
            outputter.join()

        total = time.time() - start

        # watch for changes
        total_s = click.style(
            '{:.4}s'.format(total), fg='green' if p.returncode == 0 else 'red')
        status_s = click.style(
            'ok', fg='green') if p.returncode == 0 else click.style(
                'err({})'.format(p.returncode), fg='red')

        if rerun_on_success is not None and rerun_on_success <= total:
            info(status_s + ', took {} seconds. Rerunning immediately.')
        else:
            info(status_s +
                 ', took {} seconds. Waiting for changes...'.format(total_s))

            p = subprocess.Popen(
                inotify_args,
                stderr=None if not quiet else subprocess.DEVNULL,
                stdout=None if not quiet else subprocess.DEVNULL)
            p.wait()

            if p.returncode != 0:
                exit_err(
                    'inotifywait failed: {}/{}'.format(p.stdout, p.stderr))

            if delay:
                time.sleep(delay)


if __name__ == '__main__':
    cli()
